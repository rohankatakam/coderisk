package main

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/rohankatakam/coderisk/internal/git"
	"github.com/spf13/cobra"
)

// hookCmd manages git hooks for automatic risk assessment
// Reference: ux_pre_commit_hook.md - Pre-commit hook integration
var hookCmd = &cobra.Command{
	Use:   "hook",
	Short: "Manage git hooks",
	Long:  `Install or uninstall git pre-commit hooks for automatic risk checks.`,
}

var hookInstallCmd = &cobra.Command{
	Use:   "install",
	Short: "Install pre-commit hook for automatic risk checks",
	Long: `Install git pre-commit hook to automatically check code risk before commits.

The hook runs 'crisk check --pre-commit --quiet' and blocks commits on HIGH/CRITICAL risk.

Override with: git commit --no-verify`,
	RunE: runHookInstall,
}

var hookUninstallCmd = &cobra.Command{
	Use:   "uninstall",
	Short: "Remove pre-commit hook",
	RunE:  runHookUninstall,
}

func init() {
	hookCmd.AddCommand(hookInstallCmd)
	hookCmd.AddCommand(hookUninstallCmd)
	rootCmd.AddCommand(hookCmd)
}

func runHookInstall(cmd *cobra.Command, args []string) error {
	// Detect git repository
	gitRoot, err := git.FindGitRoot()
	if err != nil {
		return fmt.Errorf("not in a git repository: %w", err)
	}

	hookPath := filepath.Join(gitRoot, ".git", "hooks", "pre-commit")

	// Check if hook already exists
	if _, err := os.Stat(hookPath); err == nil {
		return fmt.Errorf("pre-commit hook already exists at %s\nTo replace, run: crisk hook uninstall && crisk hook install", hookPath)
	}

	// Generate hook script
	hookContent := generateHookScript()

	// Write hook file with executable permissions
	if err := os.WriteFile(hookPath, []byte(hookContent), 0755); err != nil {
		return fmt.Errorf("failed to write hook: %w", err)
	}

	fmt.Println("âœ… Pre-commit hook installed successfully!")
	fmt.Printf("   Location: %s\n", hookPath)
	fmt.Println("\nðŸ’¡ What happens next?")
	fmt.Println("   â€¢ CodeRisk checks your code automatically before commits")
	fmt.Println("   â€¢ HIGH/CRITICAL risk commits are blocked")
	fmt.Println("   â€¢ Override anytime with: git commit --no-verify")
	fmt.Println("\nðŸŽ¯ Try it now:")
	fmt.Println("   git add <file>")
	fmt.Println("   git commit -m \"Test commit\"")

	return nil
}

func runHookUninstall(cmd *cobra.Command, args []string) error {
	gitRoot, err := git.FindGitRoot()
	if err != nil {
		return fmt.Errorf("not in a git repository: %w", err)
	}

	hookPath := filepath.Join(gitRoot, ".git", "hooks", "pre-commit")

	if _, err := os.Stat(hookPath); os.IsNotExist(err) {
		return fmt.Errorf("no pre-commit hook installed")
	}

	if err := os.Remove(hookPath); err != nil {
		return fmt.Errorf("failed to remove hook: %w", err)
	}

	fmt.Println("âœ… Pre-commit hook uninstalled")
	return nil
}

// generateHookScript creates the bash script for the pre-commit hook
// Reference: ux_pre_commit_hook.md Â§2 - Hook behavior design
// 12-factor: Factor 7 - Contact humans when risky (blocks on HIGH/CRITICAL)
func generateHookScript() string {
	return `#!/bin/bash
# CodeRisk pre-commit hook
# Auto-generated by 'crisk hook install'

set +e  # Don't exit on error

# Run CodeRisk check in pre-commit mode
CRISK_OUTPUT=$(crisk check --pre-commit --quiet 2>&1)
CRISK_EXIT=$?

if [ $CRISK_EXIT -eq 0 ]; then
    # Low risk or safe to commit
    echo "âœ… CodeRisk: Safe to commit"
    exit 0
elif [ $CRISK_EXIT -eq 1 ]; then
    # Risk detected - block commit
    echo "$CRISK_OUTPUT"
    echo ""
    echo "âŒ Commit blocked by CodeRisk"
    echo "Override with: git commit --no-verify"
    exit 1
else
    # Tool error (fail open - don't block commit)
    echo "âš ï¸  CodeRisk check failed (allowing commit)"
    echo "$CRISK_OUTPUT" >&2
    exit 0
fi
`
}

# Session 1 Prompt: Pre-commit Hook & Git Integration

**Duration:** 3-4 days
**Owner:** Claude Code Session 1
**Dependencies:** None (can start immediately)

---

## Context

You are implementing the **Pre-commit Hook & Git Integration** component of CodeRisk's Developer Experience (DX) Foundation phase. This is **Session 1 of 3 parallel sessions** working on different parts of the codebase simultaneously.

**Your role:** Implement automatic pre-commit risk assessment with zero-friction activation.

**Other sessions (DO NOT MODIFY THEIR FILES):**
- Session 2: Building adaptive verbosity system in `internal/output/`
- Session 3: Building AI Mode output in `internal/output/ai_mode.go` and `internal/ai/`

---

## High-Level Goal

Implement `crisk hook install` command that:
1. Installs a git pre-commit hook automatically
2. Runs `crisk check --pre-commit --quiet` on every commit
3. Blocks commits on HIGH/CRITICAL risk (configurable)
4. Allows easy override with `git commit --no-verify`
5. Logs all overrides to audit trail

---

## Your File Ownership

### Files YOU CREATE (your responsibility):
- `cmd/crisk/hook.go` - Hook install/uninstall commands
- `internal/git/staged.go` - Staged file detection
- `internal/git/repo.go` - Git repository utilities
- `internal/audit/override.go` - Override tracking/logging
- `.coderisk.yml.example` - Configuration template
- `test/integration/test_pre_commit_hook.sh` - Integration tests

### Files YOU MODIFY (minimal changes only):
- `cmd/crisk/check.go` - Add `--pre-commit` flag (1 flag, ~10 lines)
- `.gitignore` - Add `.coderisk/` directory (1 line)

### Files YOU READ ONLY (do not modify):
- `internal/output/formatter.go` - Interface from Session 2 (you'll use this)
- All integration guides in `dev_docs/03-implementation/integration_guides/`

---

## Reading List (READ THESE FIRST)

**MUST READ before coding:**
1. `dev_docs/03-implementation/integration_guides/ux_pre_commit_hook.md` - Your implementation guide
2. `dev_docs/03-implementation/PARALLEL_SESSION_PLAN.md` - Coordination with other sessions
3. `dev_docs/00-product/developer_experience.md` - UX requirements (§1 Pre-Commit Hook)
4. `dev_docs/03-implementation/phases/phase_dx_foundation.md` - Phase overview

**Reference as needed:**
5. `dev_docs/DEVELOPMENT_WORKFLOW.md` - Go development guardrails
6. `cmd/crisk/check.go` - Existing check command (to understand how to extend)

---

## Step-by-Step Implementation Plan

### Step 1: Read Documentation (30 min)
- [ ] Read all files in "Reading List" section above
- [ ] Understand pre-commit hook requirements from `ux_pre_commit_hook.md`
- [ ] Understand coordination plan from `PARALLEL_SESSION_PLAN.md`
- [ ] **ASK USER:** "I've read the documentation. Should I proceed with implementation?"

### Step 2: Implement Git Utilities (2-3 hours)

**File: `internal/git/staged.go`**
- [ ] Implement `GetStagedFiles() ([]string, error)` - Get files staged for commit
  - Use: `git diff --cached --name-only --diff-filter=ACMR`
  - Filter out empty strings
- [ ] Implement `FindGitRoot() (string, error)` - Find git repo root
  - Use: `git rev-parse --show-toplevel`

**File: `internal/git/repo.go`**
- [ ] Implement `GetCurrentBranch() (string, error)` - Get current branch name
- [ ] Implement `GetRemoteURL() (string, error)` - Get remote URL

**File: `internal/git/staged_test.go`**
- [ ] Unit tests for all git utilities (80%+ coverage)

**Checkpoint:** Run `go test ./internal/git/... -v` and verify all tests pass
**ASK USER:** "Git utilities implemented and tested. All tests pass. Should I proceed?"

---

### Step 3: Implement Hook Install Command (3-4 hours)

**File: `cmd/crisk/hook.go`**

**Create the following commands:**

```go
var hookCmd = &cobra.Command{
    Use:   "hook",
    Short: "Manage git hooks",
}

var hookInstallCmd = &cobra.Command{
    Use:   "install",
    Short: "Install pre-commit hook for automatic risk checks",
    RunE:  runHookInstall,
}

var hookUninstallCmd = &cobra.Command{
    Use:   "uninstall",
    Short: "Remove pre-commit hook",
    RunE:  runHookUninstall,
}
```

**Implementation requirements:**
- [ ] `runHookInstall()` function:
  1. Detect git repo using `git.FindGitRoot()`
  2. Check if hook already exists at `.git/hooks/pre-commit`
  3. Generate hook script using `generateHookScript()` template
  4. Write hook file with 0755 permissions (executable)
  5. Print success message with next steps

- [ ] `runHookUninstall()` function:
  1. Find and remove `.git/hooks/pre-commit`
  2. Print confirmation message

- [ ] `generateHookScript()` function - Returns bash script:
  ```bash
  #!/bin/bash
  # CodeRisk pre-commit hook
  # Auto-generated by 'crisk hook install'

  CRISK_OUTPUT=$(crisk check --pre-commit --quiet 2>&1)
  CRISK_EXIT=$?

  if [ $CRISK_EXIT -eq 0 ]; then
      # Safe to commit
      echo "✅ CodeRisk: Safe to commit"
      exit 0
  elif [ $CRISK_EXIT -eq 1 ]; then
      # Risk detected
      echo "$CRISK_OUTPUT"
      echo ""
      echo "❌ Commit blocked by CodeRisk"
      echo "Override with: git commit --no-verify"
      exit 1
  else
      # Tool error (fail open)
      echo "⚠️  CodeRisk check failed (allowing commit)"
      echo "$CRISK_OUTPUT"
      exit 0
  fi
  ```

**Checkpoint:** Run `go build ./cmd/crisk` and verify it compiles
**ASK USER:** "Hook commands implemented. Binary builds successfully. Should I proceed with check.go integration?"

---

### Step 4: Integrate with Check Command (1 hour)

**File: `cmd/crisk/check.go` (MINIMAL CHANGES ONLY)**

Add ONE flag:
```go
func init() {
    checkCmd.Flags().Bool("pre-commit", false, "Run in pre-commit hook mode")
    // ... existing flags ...
}
```

Modify `runCheck()` function:
```go
func runCheck(cmd *cobra.Command, args []string) error {
    preCommit, _ := cmd.Flags().GetBool("pre-commit")

    // Pre-commit mode: get staged files
    var files []string
    var err error

    if preCommit {
        files, err = git.GetStagedFiles()
        if err != nil {
            return fmt.Errorf("failed to get staged files: %w", err)
        }

        if len(files) == 0 {
            fmt.Println("✅ No files to check")
            return nil
        }
    } else if len(args) > 0 {
        files = args
    } else {
        files, err = git.GetChangedFiles() // Existing function
        if err != nil {
            return fmt.Errorf("failed to get changed files: %w", err)
        }
    }

    // ... rest of existing logic ...

    // Exit with appropriate code for pre-commit
    if preCommit && result.RiskLevel == "HIGH" || result.RiskLevel == "CRITICAL" {
        os.Exit(1) // Block commit
    }

    return nil
}
```

**Checkpoint:** Build and test
**ASK USER:** "Check command integrated with --pre-commit flag. Should I proceed with override tracking?"

---

### Step 5: Implement Override Tracking (2-3 hours)

**File: `internal/audit/override.go`**

```go
package audit

import (
    "encoding/json"
    "os"
    "time"
)

type OverrideEvent struct {
    Timestamp   time.Time `json:"timestamp"`
    Author      string    `json:"author"`
    CommitSHA   string    `json:"commit_sha,omitempty"`
    RiskLevel   string    `json:"risk_level"`
    FilesCount  int       `json:"files_count"`
    Issues      []string  `json:"issues"`
    Reason      string    `json:"reason,omitempty"`
}

// LogOverride records when --no-verify is used
func LogOverride(event OverrideEvent) error {
    logFile := ".coderisk/hook_log.jsonl"

    // Create directory if needed
    os.MkdirAll(".coderisk", 0755)

    f, err := os.OpenFile(logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        return err
    }
    defer f.Close()

    encoder := json.NewEncoder(f)
    return encoder.Encode(event)
}
```

**File: `internal/audit/override_test.go`**
- [ ] Unit tests for override logging

**Checkpoint:** Run tests
**ASK USER:** "Override tracking implemented and tested. Should I proceed with configuration?"

---

### Step 6: Create Configuration Template (1 hour)

**File: `.coderisk.yml.example`**

```yaml
# CodeRisk Configuration
# Copy to .coderisk.yml and customize

pre_commit:
  # Block commits on MEDIUM risk (default: true)
  block_on_medium: true

  # Block commits on LOW risk (default: false)
  block_on_low: false

  # Maximum check time before timeout (seconds)
  timeout: 5

  # Log all checks to file (for audit trail)
  log_checks: true
  log_file: ".coderisk/hook_log.jsonl"

  # Track overrides (git commit --no-verify)
  track_overrides: true

# Team mode: solo, team, standard, enterprise
team_mode: team
```

**File: `.gitignore` (append)**
```
# CodeRisk
.coderisk/
```

**ASK USER:** "Configuration template created. Should I proceed with integration tests?"

---

### Step 7: Integration Testing (2-3 hours)

**File: `test/integration/test_pre_commit_hook.sh`**

```bash
#!/bin/bash
set -e

echo "=== Pre-commit Hook Integration Test ==="

# Setup test repo
TEST_DIR=$(mktemp -d)
cd $TEST_DIR
git init
git config user.email "test@example.com"
git config user.name "Test User"

# Initialize CodeRisk (assumes crisk binary exists)
crisk init

# Test 1: Install hook
echo "Test 1: Installing hook..."
crisk hook install
if [ ! -f .git/hooks/pre-commit ]; then
    echo "❌ FAIL: Hook not installed"
    exit 1
fi
echo "✅ PASS: Hook installed"

# Test 2: Safe commit (should succeed)
echo "Test 2: Safe commit..."
echo "// Safe code" > safe.go
git add safe.go
git commit -m "Safe commit" || {
    echo "❌ FAIL: Safe commit blocked"
    exit 1
}
echo "✅ PASS: Safe commit succeeded"

# Test 3: Risky commit (should fail)
echo "Test 3: Risky commit..."
echo "// Risky code with no tests" > auth.go
git add auth.go
if git commit -m "Add auth" 2>&1 | grep -q "Commit blocked"; then
    echo "✅ PASS: Risky commit blocked"
else
    echo "❌ FAIL: Risky commit not blocked"
    exit 1
fi

# Test 4: Override (should succeed)
echo "Test 4: Override..."
git commit --no-verify -m "Add auth (override)" || {
    echo "❌ FAIL: Override failed"
    exit 1
}
echo "✅ PASS: Override succeeded"

# Test 5: Uninstall hook
echo "Test 5: Uninstalling hook..."
crisk hook uninstall
if [ -f .git/hooks/pre-commit ]; then
    echo "❌ FAIL: Hook not uninstalled"
    exit 1
fi
echo "✅ PASS: Hook uninstalled"

# Cleanup
cd /
rm -rf $TEST_DIR

echo "=== All tests passed! ==="
```

**Make executable:** `chmod +x test/integration/test_pre_commit_hook.sh`

**Checkpoint:** Run integration tests
**ASK USER:** "Integration test created. Ready to run end-to-end test. Should I execute: `./test/integration/test_pre_commit_hook.sh`?"

---

### Step 8: Final Validation & Documentation (1 hour)

**Validation checklist:**
- [ ] Run `go build ./cmd/crisk` - Verify compiles
- [ ] Run `go test ./internal/git/... -v` - Verify git utils work
- [ ] Run `go test ./internal/audit/... -v` - Verify override tracking works
- [ ] Run `./test/integration/test_pre_commit_hook.sh` - Verify end-to-end
- [ ] Test hook in real repo: Install hook, commit safe/risky code

**Performance check:**
- [ ] Time a pre-commit check: `time crisk check --pre-commit --quiet`
- [ ] Verify <2s for cached results, <5s for cold start
- [ ] **ASK USER:** "Performance results: [X]s. Is this acceptable? (<2s cached, <5s cold target)"

**Documentation:**
- [ ] Update `dev_docs/03-implementation/status.md`:
  - Mark pre-commit hook as ✅ Complete
  - Mark git integration as ✅ Complete
  - Mark override tracking as ✅ Complete

**ASK USER:** "Session 1 complete! All tests pass. Should I update status.md and mark deliverables complete?"

---

## Critical Checkpoints (Human Verification Required)

### Checkpoint 1: After Step 2 (Git Utilities)
**YOU ASK:** "Git utilities tested. Results: [test output]. All tests pass: YES/NO. Should I proceed?"
**WAIT FOR:** User confirmation

### Checkpoint 2: After Step 4 (Check Integration)
**YOU ASK:** "Modified cmd/crisk/check.go with --pre-commit flag. Binary compiles. Should I proceed with override tracking?"
**WAIT FOR:** User confirmation

### Checkpoint 3: After Step 7 (Integration Tests)
**YOU ASK:** "Integration test ready. Should I run: `./test/integration/test_pre_commit_hook.sh`?"
**WAIT FOR:** User confirmation and review of test results

### Checkpoint 4: Final (Before completion)
**YOU ASK:** "All deliverables complete. Performance: [X]s. Tests: [pass/fail]. Ready to mark session complete?"
**WAIT FOR:** User final approval

---

## Coordination with Other Sessions

### DO NOT MODIFY (other sessions own these):
- `internal/output/quiet.go` - Session 2
- `internal/output/standard.go` - Session 2
- `internal/output/explain.go` - Session 2
- `internal/output/ai_mode.go` - Session 3
- `internal/ai/*` - Session 3

### YOU MAY USE (after Session 2 creates):
- `internal/output/formatter.go` - Interface from Session 2
- Use `output.NewFormatter(output.VerbosityQuiet)` in pre-commit hook

### WAIT FOR (before using formatter):
- **Session 2 to create `internal/output/formatter.go`**
- **ASK USER:** "Has Session 2 created internal/output/formatter.go? Can I import it?"

---

## Success Criteria

**Functional:**
- [ ] `crisk hook install` creates working pre-commit hook
- [ ] Hook runs automatically on `git commit`
- [ ] Blocks HIGH/CRITICAL risk commits by default
- [ ] Allows override with `--no-verify`
- [ ] Logs overrides to `.coderisk/hook_log.jsonl`

**Performance:**
- [ ] Pre-commit check <2s (cached)
- [ ] Pre-commit check <5s (cold start)

**Quality:**
- [ ] 80%+ unit test coverage
- [ ] Integration test passes
- [ ] No merge conflicts with other sessions

---

## Error Handling

**If you encounter issues:**
1. **File conflicts:** Check PARALLEL_SESSION_PLAN.md - you may be modifying a file owned by another session
2. **Interface not found:** Wait for Session 2 to create `internal/output/formatter.go`
3. **Build errors:** Ask user for verification before proceeding
4. **Test failures:** Report to user, get guidance before continuing

**Always ask before:**
- Modifying files not in your ownership list
- Installing new dependencies
- Changing existing interfaces
- Making breaking changes

---

## Final Deliverables

When complete, you should have:
1. ✅ Working pre-commit hook installation command
2. ✅ Git utilities for staged file detection
3. ✅ Override tracking and audit logging
4. ✅ Integration with check command (--pre-commit flag)
5. ✅ Configuration template (.coderisk.yml.example)
6. ✅ Integration test suite
7. ✅ Updated status.md documentation

---

## Questions to Ask During Implementation

- "I've read the documentation. Should I proceed with implementation?"
- "Git utilities implemented and tested. Should I proceed?"
- "Has Session 2 created internal/output/formatter.go? Can I import it?"
- "Check command integrated. Should I proceed with override tracking?"
- "Integration test ready. Should I run it?"
- "Performance results: [X]s. Is this acceptable?"
- "Session 1 complete! Should I update status.md?"

**Remember:** You are one of 3 parallel sessions. Stay in your file ownership boundaries and coordinate via checkpoints!

# UX Integration Guide: Pre-Commit Hook

**Purpose:** Implement automatic pre-commit risk assessment with zero-friction activation
**Last Updated:** October 4, 2025
**Reference:** [developer_experience.md](../../00-product/developer_experience.md) ¬ß1 - Pre-Commit Automatic Assessment

> **Design Principle:** Risk check happens automatically before every commit, no developer action required. (12-factor: Factor 7 - Contact humans when risky)

---

## Overview

The pre-commit hook is CodeRisk's **primary UX touchpoint** - providing automatic risk assessment before code is committed. It's designed to be:

- **Zero-friction:** Installs with one command, works transparently
- **Fast:** <2s for cached results, <5s for cold start
- **Non-intrusive:** Quiet mode for success, verbose only on issues
- **Override-friendly:** Simple `--no-verify` escape hatch

---

## Implementation Strategy

### 1. Hook Installation Command

**File:** `cmd/crisk/hook.go`

```go
package main

import (
    "fmt"
    "os"
    "path/filepath"

    "github.com/coderisk/coderisk-go/internal/git"
    "github.com/spf13/cobra"
)

var hookCmd = &cobra.Command{
    Use:   "hook",
    Short: "Manage git hooks",
}

var hookInstallCmd = &cobra.Command{
    Use:   "install",
    Short: "Install pre-commit hook for automatic risk checks",
    Long: `Install git pre-commit hook to automatically check code risk before commits.

The hook runs 'crisk check --pre-commit --quiet' and blocks commits on HIGH/CRITICAL risk.

Override with: git commit --no-verify`,
    RunE: runHookInstall,
}

var hookUninstallCmd = &cobra.Command{
    Use:   "uninstall",
    Short: "Remove pre-commit hook",
    RunE:  runHookUninstall,
}

func init() {
    hookCmd.AddCommand(hookInstallCmd)
    hookCmd.AddCommand(hookUninstallCmd)
    rootCmd.AddCommand(hookCmd)
}

func runHookInstall(cmd *cobra.Command, args []string) error {
    // Detect git repository
    gitRoot, err := git.FindGitRoot()
    if err != nil {
        return fmt.Errorf("not in a git repository: %w", err)
    }

    hookPath := filepath.Join(gitRoot, ".git", "hooks", "pre-commit")

    // Check if hook already exists
    if _, err := os.Stat(hookPath); err == nil {
        return fmt.Errorf("pre-commit hook already exists at %s\nTo replace, run: crisk hook uninstall && crisk hook install", hookPath)
    }

    // Generate hook script
    hookContent := generateHookScript()

    // Write hook file
    if err := os.WriteFile(hookPath, []byte(hookContent), 0755); err != nil {
        return fmt.Errorf("failed to write hook: %w", err)
    }

    fmt.Println("‚úÖ Pre-commit hook installed successfully!")
    fmt.Printf("   Location: %s\n", hookPath)
    fmt.Println("\nüí° The hook will run automatically before each commit.")
    fmt.Println("   Override with: git commit --no-verify")

    return nil
}

func runHookUninstall(cmd *cobra.Command, args []string) error {
    gitRoot, err := git.FindGitRoot()
    if err != nil {
        return fmt.Errorf("not in a git repository: %w", err)
    }

    hookPath := filepath.Join(gitRoot, ".git", "hooks", "pre-commit")

    if _, err := os.Stat(hookPath); os.IsNotExist(err) {
        return fmt.Errorf("no pre-commit hook installed")
    }

    if err := os.Remove(hookPath); err != nil {
        return fmt.Errorf("failed to remove hook: %w", err)
    }

    fmt.Println("‚úÖ Pre-commit hook uninstalled")
    return nil
}

func generateHookScript() string {
    return `#!/bin/bash
# CodeRisk pre-commit hook
# Auto-generated by 'crisk hook install'

# Run CodeRisk check in pre-commit mode
CRISK_OUTPUT=$(crisk check --pre-commit --quiet 2>&1)
CRISK_EXIT=$?

if [ $CRISK_EXIT -eq 0 ]; then
    # Low risk or warnings only
    echo "‚úÖ CodeRisk: Safe to commit"
    exit 0
elif [ $CRISK_EXIT -eq 1 ]; then
    # Medium/High risk detected
    echo "$CRISK_OUTPUT"
    echo ""
    echo "‚ùå Commit blocked by CodeRisk"
    echo "Override with: git commit --no-verify"
    exit 1
else
    # Tool error (don't block commit)
    echo "‚ö†Ô∏è  CodeRisk check failed (allowing commit)"
    echo "$CRISK_OUTPUT"
    exit 0
fi
`
}
```

### 2. Pre-Commit Check Mode

**File:** `cmd/crisk/check.go` (extend existing)

```go
func init() {
    checkCmd.Flags().Bool("pre-commit", false, "Run in pre-commit hook mode")
    checkCmd.Flags().Bool("quiet", false, "Quiet output (one-line summary)")
    // ... other flags
}

func runCheck(cmd *cobra.Command, args []string) error {
    preCommit, _ := cmd.Flags().GetBool("pre-commit")
    quiet, _ := cmd.Flags().GetBool("quiet")

    // Pre-commit mode implies quiet
    if preCommit {
        quiet = true
    }

    // Get staged files (if pre-commit mode)
    var files []string
    var err error

    if preCommit {
        files, err = git.GetStagedFiles()
        if err != nil {
            return fmt.Errorf("failed to get staged files: %w", err)
        }

        if len(files) == 0 {
            fmt.Println("‚úÖ No files to check")
            return nil
        }
    } else if len(args) > 0 {
        files = args
    } else {
        // Default: check changed files in working directory
        files, err = git.GetChangedFiles()
        if err != nil {
            return fmt.Errorf("failed to get changed files: %w", err)
        }
    }

    // Run risk assessment
    result, err := runRiskAssessment(cmd.Context(), files)
    if err != nil {
        return err
    }

    // Format output based on verbosity
    var formatter output.Formatter
    if quiet {
        formatter = output.NewFormatter(output.VerbosityQuiet)
    } else {
        formatter = output.NewFormatter(output.VerbosityStandard)
    }

    if err := formatter.Format(result, os.Stdout); err != nil {
        return err
    }

    // Exit with appropriate code
    return exitWithRiskLevel(result.RiskLevel, preCommit)
}

func exitWithRiskLevel(riskLevel string, preCommit bool) error {
    // In pre-commit mode, block on MEDIUM+ risk
    if preCommit {
        switch riskLevel {
        case "HIGH", "CRITICAL":
            os.Exit(1) // Block commit
        case "MEDIUM":
            // Configurable: block or warn (default: block)
            blockOnMedium := viper.GetBool("pre_commit.block_on_medium")
            if blockOnMedium {
                os.Exit(1)
            }
        }
    }

    return nil
}
```

### 3. Git Integration Utilities

**File:** `internal/git/staged.go`

```go
package git

import (
    "os/exec"
    "strings"
)

// GetStagedFiles returns list of files staged for commit
func GetStagedFiles() ([]string, error) {
    cmd := exec.Command("git", "diff", "--cached", "--name-only", "--diff-filter=ACMR")
    output, err := cmd.Output()
    if err != nil {
        return nil, err
    }

    files := strings.Split(strings.TrimSpace(string(output)), "\n")

    // Filter out empty strings
    var result []string
    for _, f := range files {
        if f != "" {
            result = append(result, f)
        }
    }

    return result, nil
}

// FindGitRoot returns the root directory of the git repository
func FindGitRoot() (string, error) {
    cmd := exec.Command("git", "rev-parse", "--show-toplevel")
    output, err := cmd.Output()
    if err != nil {
        return "", err
    }

    return strings.TrimSpace(string(output)), nil
}
```

---

## Hook Behavior Design

### Exit Code Strategy

| Risk Level | Pre-Commit Exit Code | Behavior |
|-----------|---------------------|----------|
| NONE/LOW | 0 | ‚úÖ Allow commit silently |
| MEDIUM | 1 (configurable) | ‚ö†Ô∏è  Block or warn (see config) |
| HIGH | 1 | ‚ùå Block commit |
| CRITICAL | 1 | ‚ùå Block commit |
| Tool Error | 0 | ‚ö†Ô∏è  Allow commit (fail open) |

**Design Rationale:**
- **Fail open on errors:** Don't block commits if CodeRisk itself fails
- **Configurable MEDIUM blocking:** Teams choose strictness level
- **Always allow override:** `--no-verify` provides escape hatch

### Output Examples

**Success (low risk):**
```bash
$ git commit -m "Fix typo"
‚úÖ CodeRisk: Safe to commit
[main abc1234] Fix typo
 1 file changed, 1 insertion(+), 1 deletion(-)
```

**Risk detected (blocking):**
```bash
$ git commit -m "Add payment processing"
‚ö†Ô∏è  HIGH risk: 3 issues detected
Run 'crisk check' for details

‚ùå Commit blocked by CodeRisk
Override with: git commit --no-verify
```

**Override:**
```bash
$ git commit --no-verify -m "Add payment processing"
‚ö†Ô∏è  CodeRisk check bypassed (override logged)
[main def5678] Add payment processing
 3 files changed, 145 insertions(+), 12 deletions(-)
```

**Tool error (fail open):**
```bash
$ git commit -m "Refactor auth"
‚ö†Ô∏è  CodeRisk check failed (allowing commit)
Error: failed to connect to graph database

[main ghi9012] Refactor auth
 2 files changed, 67 insertions(+), 34 deletions(-)
```

---

## Configuration

### Hook Behavior Settings

**File:** `.coderisk.yml` (project config)

```yaml
pre_commit:
  # Block commits on MEDIUM risk (default: true)
  block_on_medium: true

  # Block commits on LOW risk (default: false)
  block_on_low: false

  # Maximum check time before timeout (seconds)
  timeout: 5

  # Log all checks to file (for audit trail)
  log_checks: true
  log_file: ".coderisk/hook_log.jsonl"

  # Track overrides (git commit --no-verify)
  track_overrides: true
```

### Team Mode Integration

Different teams need different strictness levels (from [developer_experience.md](../../00-product/developer_experience.md) ¬ß3):

**Solo Developer:**
```yaml
pre_commit:
  block_on_medium: false  # Warn only
  block_on_low: false
  mode: solo
```

**Startup/Small Team:**
```yaml
pre_commit:
  block_on_medium: true   # Block on HIGH/CRITICAL only
  block_on_low: false
  mode: team
```

**Enterprise:**
```yaml
pre_commit:
  block_on_medium: true   # Block on MEDIUM+
  block_on_low: true      # Very strict
  mode: enterprise
  require_approval: true  # Override needs manager approval
```

---

## Override Tracking

### Audit Log Design

**File:** `internal/audit/override.go`

```go
package audit

import (
    "encoding/json"
    "os"
    "time"
)

type OverrideEvent struct {
    Timestamp   time.Time `json:"timestamp"`
    Author      string    `json:"author"`
    CommitSHA   string    `json:"commit_sha,omitempty"`
    RiskLevel   string    `json:"risk_level"`
    FilesCount  int       `json:"files_count"`
    Issues      []string  `json:"issues"`
    Reason      string    `json:"reason,omitempty"`
}

// LogOverride records when --no-verify is used
func LogOverride(event OverrideEvent) error {
    logFile := ".coderisk/hook_log.jsonl"

    f, err := os.OpenFile(logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        return err
    }
    defer f.Close()

    encoder := json.NewEncoder(f)
    return encoder.Encode(event)
}
```

**Hook integration:**
```bash
# Modified hook script to track overrides
if [ -n "$CRISK_NO_VERIFY" ]; then
    # Detected --no-verify override
    crisk internal log-override \
        --risk-level "$RISK_LEVEL" \
        --files-count "$FILES_COUNT"
fi
```

### Override Dashboard (Future)

Teams can view override patterns:
```bash
crisk hook stats

CodeRisk Override Statistics (Last 30 Days)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Total commits: 234
Blocked by CodeRisk: 18 (7.7%)
Overrides (--no-verify): 5 (2.1%)

Top override reasons:
1. "Urgent hotfix" (3 overrides)
2. "WIP, will fix in next commit" (2 overrides)

Most overridden files:
1. src/auth.py (3 overrides)
2. src/payment.py (2 overrides)
```

---

## Performance Optimization

### 2-Second Rule

**Target:** <2s for cached results, <5s for cold start

**Optimization strategies:**

1. **Cache staged file hashes:**
```go
// internal/cache/file_hash.go
func GetCachedRiskResult(files []string) (*RiskResult, bool) {
    // Compute hash of file contents + git SHA
    hash := hashFiles(files)

    // Check 15-min cache
    if cached, ok := riskCache.Get(hash); ok {
        return cached.(*RiskResult), true
    }

    return nil, false
}
```

2. **Parallel file analysis:**
```go
// Analyze files concurrently
var wg sync.WaitGroup
results := make(chan *FileRisk, len(files))

for _, file := range files {
    wg.Add(1)
    go func(f string) {
        defer wg.Done()
        risk := analyzeFile(ctx, f)
        results <- risk
    }(file)
}
```

3. **Timeout enforcement:**
```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

result, err := runRiskAssessment(ctx, files)
if err == context.DeadlineExceeded {
    // Fail open on timeout
    fmt.Println("‚ö†Ô∏è  Check timed out (allowing commit)")
    os.Exit(0)
}
```

---

## Error Handling

### Graceful Degradation

**Principle:** Never block commits due to tool failures

```bash
#!/bin/bash
# Enhanced hook with error handling

set +e  # Don't exit on error

CRISK_OUTPUT=$(crisk check --pre-commit --quiet 2>&1)
CRISK_EXIT=$?

if [ $CRISK_EXIT -eq 2 ]; then
    # Exit code 2 = tool error
    echo "‚ö†Ô∏è  CodeRisk check failed (allowing commit)"
    echo "$CRISK_OUTPUT" >&2
    exit 0  # Allow commit
fi

if [ $CRISK_EXIT -eq 1 ]; then
    # Exit code 1 = risk detected
    echo "$CRISK_OUTPUT"
    echo ""
    echo "‚ùå Commit blocked by CodeRisk"
    echo "Override with: git commit --no-verify"
    exit 1  # Block commit
fi

# Exit code 0 = safe to commit
echo "‚úÖ CodeRisk: Safe to commit"
exit 0
```

**Exit codes:**
- `0`: Safe to commit
- `1`: Risk detected (block)
- `2`: Tool error (allow commit)

---

## Testing Strategy

### Unit Tests

**File:** `cmd/crisk/hook_test.go`

```go
func TestHookInstall(t *testing.T) {
    // Setup temporary git repo
    tmpDir := setupTempGitRepo(t)
    defer os.RemoveAll(tmpDir)

    // Run hook install
    err := runHookInstall(nil, nil)
    assert.NoError(t, err)

    // Verify hook file exists
    hookPath := filepath.Join(tmpDir, ".git", "hooks", "pre-commit")
    assert.FileExists(t, hookPath)

    // Verify hook is executable
    info, _ := os.Stat(hookPath)
    assert.True(t, info.Mode()&0111 != 0)

    // Verify hook content
    content, _ := os.ReadFile(hookPath)
    assert.Contains(t, string(content), "crisk check --pre-commit")
}
```

### Integration Tests

```bash
# test/integration/test_pre_commit_hook.sh

#!/bin/bash

# Setup test repo
git init test_repo
cd test_repo
crisk init

# Install hook
crisk hook install

# Test 1: Safe commit (LOW risk)
echo "// Safe code" > safe.go
git add safe.go
git commit -m "Safe commit"  # Should succeed

# Test 2: Risky commit (HIGH risk)
echo "// Risky code with no tests" > auth.go
git add auth.go
git commit -m "Add auth"  # Should fail

# Test 3: Override
git commit --no-verify -m "Add auth (override)"  # Should succeed

# Verify override was logged
cat .coderisk/hook_log.jsonl | jq .
```

---

## User Education

### First-Time Installation Message

```
crisk hook install

‚úÖ Pre-commit hook installed successfully!
   Location: /path/to/repo/.git/hooks/pre-commit

üí° What happens next?

   ‚Ä¢ Every time you run 'git commit', CodeRisk will check your code
   ‚Ä¢ If HIGH risk is detected, the commit will be blocked
   ‚Ä¢ You'll see exactly what's risky and how to fix it
   ‚Ä¢ Override anytime with: git commit --no-verify

üéØ Try it now:

   git add <file>
   git commit -m "Test commit"
```

### Hook Triggered Message (First Time)

```
git commit -m "Add feature"

üîç CodeRisk: Analyzing staged files... (1.2s)

‚ö†Ô∏è  MEDIUM risk detected:

   Issues:
   1. auth.py has 0% test coverage
   2. payment.py calls 8 other functions (high coupling)

   Recommendations:
   - Add tests for auth.py
   - Review coupling with database.py

   Run 'crisk check --explain' for investigation details

‚ùå Commit blocked. Fix issues or override with 'git commit --no-verify'
```

---

## Next Steps

1. Implement `cmd/crisk/hook.go` with install/uninstall commands
2. Add `--pre-commit` mode to `cmd/crisk/check.go`
3. Implement `internal/git/staged.go` for staged file detection
4. Add override tracking to audit log
5. Create integration tests for hook behavior
6. Document team configuration options

---

**See also:**
- [developer_experience.md](../../00-product/developer_experience.md) - UX design philosophy
- [ux_adaptive_verbosity.md](ux_adaptive_verbosity.md) - Quiet mode used in pre-commit
- [ux_team_modes.md](ux_team_modes.md) - Team-specific hook behavior (when created)
- [DEVELOPMENT_WORKFLOW.md](../../DEVELOPMENT_WORKFLOW.md) - Implementation guardrails
